/*
 *
 * dsmail.c - Modifies/parses mail to discuss
 *
 *        $Source: /afs/dev.mit.edu/source/repository/athena/bin/discuss/mclient/dsmail.c.old,v $
 *
 *        $Log: not supported by cvs2svn $
 * Revision 1.3  87/05/02  02:12:58  tytso
 * Replaced the regexp and options parsing code with the UNIX
 * library routines.  Cleaned up code.  Added -A (all headers)
 * option.
 * 
 */

#include <stdio.h>
#include <strings.h>
#include <ctype.h>

#define DSPIPE		"/usr/sipb/bin/dspipe"
#define DEFAULT_SUBJECT "No subject found in mail header"
#define BUFFLEN 400
#define LISTLEN 40

#ifndef	lint
static char rcsid[] = "$Header: /afs/dev.mit.edu/source/repository/athena/bin/discuss/mclient/dsmail.c.old,v 1.4 1987-07-17 03:34:57 tytso Exp $";
#endif

char *malloc();
char *mktemp();
FILE *popen();
FILE *fopen();
FILE *fdopen();
int getopt();

extern char *optarg;                /* External variables for getopt */
extern int optind;

char *deflist[] = {
	"^to$","^from$","^cc$",".*-to$",".*-from$","^date$",NULL
};
		
char *subjlist[] = {
	"subject",NULL
};

char *progname;
char *save[LISTLEN],*reject[LISTLEN];
char *usr_mtg = "";
int 	dodefs=0,
	allfields=0,
	debug=0;
char *optarg;
int optind;
char *dspipeloc;

void PRS();
void MakeLowerCase();
void PipeToMeeting();

main(argc,argv)
	int argc;
	char *argv[];
{
	FILE *f;
	char line[BUFFLEN+1],*keyword,*key;
	char *subject=NULL;
	int i,ok_prev=0,iscont = 0;
	char filename[60];

	PRS(argc,argv);
	line[BUFFLEN]='\0';
	if (debug) 
		f=stdout;
	else {
		(void) mktemp(strcpy(filename, "/tmp/DSXXXXXX"));
		if ((f = fopen(filename,"w+")) == NULL)
			perror(filename);
		if (fchmod(fileno(f),0600))
			perror("chmod temp file");
	}
	
	if (fgets(line,BUFFLEN,stdin)==NULL)
		exit(0);
	if (isspace(line[0]))
		iscont = 1;
	while (*line != '\n') {
		if (!iscont) {
			for (i=0;line[i] && line[i]!=':';i++) ;
			keyword=malloc(i+1);
			(void) strncpy(keyword,line,i);
			keyword[i]='\0';
			key=malloc(i+1);
			MakeLowerCase(strcpy(key,keyword));
			if (list_compare(key,subjlist)) {
				for (i++;line[i]==' ';i++) ;
				/* if luser tries two subject lines, we */
				/* ignore the second subject line */
				if (subject==NULL) {
					subject=malloc(strlen(line)-i+1);
					(void) strcpy(subject,line+i);
				}	
			}
		}
		if ((ok_prev && iscont) || (!iscont && CheckField(key))) {
			ok_prev=1;
			fprintf(f,"%s",line);
		} else
			ok_prev=0;
		if (!iscont) {
			free(key);
			free(keyword);
		}
		iscont = line[strlen(line)-1] != '\n';
		if (fgets(line,BUFFLEN,stdin)==NULL)
			goto bye;
	}
	while (fgets(line,BUFFLEN,stdin)!=NULL) {
		fprintf(f,"%s",line);
	}
	PipeToMeeting(f,(subject==NULL) ? DEFAULT_SUBJECT : subject);
 bye:
	if (!debug)
		(void) unlink(filename); 
	exit(0);
	
}

void PipeToMeeting(f,subject)
	char *subject;
	FILE *f;
{
	char command[384], line[255];
	int len;
	FILE *dspipe;

	len=strlen(subject);
	if (len && (subject[--len] == '\n'))
		subject[len]='\0';
	(void) sprintf(command,"%s %s -t \"%s\"",dspipeloc,usr_mtg,subject);
	if (debug) {
		printf("<----------------- End of Text\n");
		printf("pipe to: %s\n",command);
		return;
	}
	if (rewind(f) == -1)
		perror("rewind");
	if ((dspipe = popen(command,"w")) == NULL)
		{
			fprintf(stderr,"Can't fork to %s",DSPIPE);
			exit(1);
		}

	while (fgets(line,BUFFLEN,f))
		(void) fputs(line,dspipe);

	(void) pclose(dspipe);
	(void) fclose(f);
}

void MakeLowerCase(s)
	char *s;
{
	int i;
	for (i=0;s[i];i++)
		s[i]=isupper(s[i]) ? tolower(s[i]) : s[i];
}

int CheckField(key)
	char *key;
{
	int keepfield;

	keepfield=allfields;
	if (!keepfield && dodefs && list_compare(key,deflist))
		keepfield=1;
	if (!keepfield && list_compare(key,save))
		keepfield=1;
	if (keepfield && list_compare(key,reject))
		keepfield=0;
	return(keepfield);
}

/* Parse command line arguments */
void PRS(argc,argv)
	int argc;
	char **argv;
{
	int c,rp,sp;
	
	progname=argv[0];
	dspipeloc = DSPIPE;
	sp=rp=0;
	optind=1;		/* Initialize for getopt */
	while ((c = getopt(argc,argv,"AZDda:r:p:")) != EOF)
		switch(c) {
		case 'd':
			dodefs=!dodefs;
			break;
		case 'D':
			debug=!debug;
			break;
		case 'A':
			allfields=!allfields;
			break;
		case 'a':
			MakeLowerCase(optarg);
			save[sp++]=optarg;
			if (sp>=LISTLEN) {
				fprintf(stderr,"Too many accept fields\n");
				exit(1);
			}
			break;
		case 'r':
			MakeLowerCase(optarg);
			reject[rp++]=optarg;
			if (sp>=LISTLEN) {
				fprintf(stderr,"Too many reject fields\n");
				exit(1);
			}
		case 'p':
			dspipeloc = optarg;
			break;
		}    
	if (optind>=argc) 
		goto lusage;
	usr_mtg=argv[optind];
	save[sp]=NULL;		/* Insert terminators */
	reject[rp]=NULL;
	return;
 lusage:
	printf("Usage: %s [-dADZ] [-a field] [-r field] meeting-path-name\n",
	       progname);
	exit(1);
}

char *re_comp();

int list_compare(s,list)
	char *s,**list;
{
	char *err;

	while (*list!=NULL) {
		err=re_comp(*list++);
		if (err) {
			fprintf(stderr,"%s: %s - %s\n",progname,err,*(--list));
			exit(1);
			}
		if (re_exec(s))
			return(1);
	}
	return(0);
}

