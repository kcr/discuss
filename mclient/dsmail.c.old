/*
 *
 * dsmailp.c - Modifies/parses mail to discuss
 *
 */

#include <stdio.h>
#include <strings.h>
#include <ctype.h>

#define DSPIPE		"nullpipe"
char *mktemp();
FILE *popen();


char *zippy[] = {
	"[Yy]ow!","[Ss]narl","[Zz]ippy",NULL 
};
	
char *deflist[] = {
	"[Tt]o","[Ff]rom","[Cc]c","*-[Tt]o","*-[Ff]rom",NULL
};
		
char *subjlist[] = {
	"subject",NULL
};
			
FILE *dspipe,*f;
char filename[40];
char command[80];
char subject[80],line[255],keyword[40],key[40];
char *save[20],*reject[20];
char *usr_mtg = "";
char *j,*foo;
int i;
int keepfield;
int zipgun=1,
dodefs=0,
debug=0;

FILE *popen();
FILE *fopen();
FILE *fdopen();

main(argc,argv)
	int argc;
	char *argv[];
{
	PRS(argc,argv);
	if (debug) {
		if ((f = fopen("/dev/tty","w")) == NULL) {
			(void) fprintf(stderr,"Cant't open stout\n");
			exit(1);
		}
	}
	else {
		(void) strcpy(filename, "/tmp/DSXXXXXX");
		(void) mktemp(filename);
		if ((f = fopen(filename,"w")) == NULL) {
			(void) fprintf (stderr, "Can't open temp file\n");
			exit (1);
		}
	}
	
	if (gets(line)==NULL)
		exit(0);
	while (*line != '\0') {
		keepfield=0;
		i=0;
		while (line[i] && line[i]!=':') 
			{
				keyword[i]=line[i];
				key[i]=isupper(line[i]) ? tolower(line[i]) : line[i];
				i++;
			}
		key[i]=keyword[i]='\0';
		if (list_compare(key,subjlist))
			strcpy(subject,line+i+1);
		if (dodefs && list_compare(key,deflist))
			keepfield=1;
		if (list_compare(key,save))
			keepfield=1;
		if (list_compare(key,reject))
			keepfield=0;
		if (keepfield)
			fprintf(f,"%s\n",line);
		if (zipgun && list_compare(key,zippy))
			fprintf(f,"%s: <CENSORED by the Net-Police>\n",keyword);
		if (gets(line)==NULL)
			goto bye;
	}     
	fprintf(f,"\n");
	while (gets(line)!=NULL)
		fprintf(f,"%s\n",line);
	if (*subject=='\0')
		strcpy(subject,"I'm sorry, Captain, but I can't find a subject!");
	if (debug)
		goto bye;
	fclose(f);
	f = fopen(filename,"r");
	sprintf(command,"%s %s -t \"%s\"",DSPIPE,usr_mtg,subject);
	dspipe = popen(command,"w");
	if (dspipe == NULL) 
		{
			fprintf(stderr,"Can't fork to %s",DSPIPE);
			exit(1);
		}
	fgets(line,255,f);
	while (!feof(f)) {
		fputs(line,dspipe);
		fgets(line,255,f);
	}
 bye:
	if (debug) {
		printf("Subject: %s\n",subject);
		printf("Meeting: %s\n",usr_mtg);
		exit(0);
	}
	(void) pclose(dspipe);
	(void) fclose(f);
	(void) unlink(filename); 
	exit(0);
	
}

/* Parse command line arguments */
PRS(argc,argv)
	int argc;
	char **argv;
{
	int i,rp,sp;
	
	sp=rp=0;
	for (i=1;i<argc;i++) {
		if (*argv[i]=='-')  {
			switch (*(argv[i]+1)) {
			case 'Z':  
				zipgun=!zipgun;
				break;
			case 'd':
				dodefs=!dodefs;
				break;
			case 'D':
				debug=!debug;
				break;
			case 'a':
				save[sp++]=argv[i]+2;
				save[sp]=NULL;
				break;
			case 'r':
				reject[rp++]=argv[i]+2;
				reject[rp]=NULL;
				break;
			default:
				goto lusage;
			}    
		}
		else {
			if (*usr_mtg != '\0')
				goto lusage;
			usr_mtg=argv[i];
		}
	}
	return;
 lusage:
	printf("No you fool!\n");
	exit(1);
}

int list_compare(s,list)
	char s[],*list[];
{
	while (*list!=NULL) 
		if (wildmat(s,*list++))
			return(1);
	return(0);
}

/*
 **  Do shell-style pattern matching for ?, \, [], and * characters.
 **  Might not be robust in face of malformed patterns; e.g., "foo[a-"
 **  could cause a segmentation violation.
 **
 **  Written by Rich $alz, mirror!rs, Wed Nov 26 19:03:17 EST 1986.
 */

#define TRUE		1
#define FALSE		0


static int
Star(s, p)
	register char	*s;
	register char	*p;
{
	while (wildmat(s, p) == FALSE)
		if (*++s == '\0')
			return(FALSE);
	return(TRUE);
}


int
wildmat(s, p)
	register char	*s;
	register char	*p;
{
	register int 	 last;
	register int 	 matched;
	register int 	 reverse;
	
	for ( ; *p; s++, p++)
		switch (*p) {
		case '\\':
			/* Literal match with following character; fall through. */
			p++;
		default:
			if (*s != *p)
				return(FALSE);
			continue;
		case '?':
			/* Match anything. */
			if (*s == '\0')
				return(FALSE);
			continue;
		case '*':
			/* Trailing star matches everything. */
			return(*++p ? Star(s, p) : TRUE);
		case '[':
			/* [^....] means inverse character class. */
			if (reverse = p[1] == '^')
				p++;
			for (last = 0400, matched = FALSE; *++p && *p != ']'; last = *p)
				/* This next line requires a good C compiler. */
				if (*p == '-' ? *s <= *++p && *s >= last : *s == *p)
					matched = TRUE;
			if (matched == reverse)
				return(FALSE);
			continue;
		}
	
	return(*s == '\0');
}




