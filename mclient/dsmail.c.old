/*
 *
 * dsmail.c - Modifies/parses mail to discuss
 *
 *        $Source: /afs/dev.mit.edu/source/repository/athena/bin/discuss/mclient/dsmail.c.old,v $
 *
 *        $Log: not supported by cvs2svn $
 */

#include <stdio.h>
#include <strings.h>
#include <ctype.h>

#define DSPIPE		"/site/sipb/bin/dspipe"
#define DEFAULT_SUBJECT "No subject found in mail header"

#ifndef	lint
static char rcsid[] = "$Header: /afs/dev.mit.edu/source/repository/athena/bin/discuss/mclient/dsmail.c.old,v 1.3 1987-05-02 02:12:58 tytso Exp $";
#endif

char *mktemp();
FILE *popen();
FILE *fopen();
FILE *fdopen();
int getopt();

extern char *optarg;                /* External variables for getopt */
extern int optind;

char *zippy[] = {
	"yow!","snarl","zippy",NULL 
};
	
char *deflist[] = {
	"^to$","^from$","^cc$",".*-to$",".*-from$",NULL
};
		
char *subjlist[] = {
	"subject",NULL
};

char *progname;
char *save[20],*reject[20];
char *usr_mtg = "";
int zipgun=0,
	dodefs=0,
	allfields=0,
	debug=0;
char *optarg;
int optind;

void PRS();
void MakeLowerCase();
void PipeToMeeting();
void perror();

main(argc,argv)
	int argc;
	char *argv[];
{
	FILE *f;
	char subject[80],line[255],keyword[40],key[40];
	int i;
	char filename[60];

	PRS(argc,argv);
	if (debug) 
		f=stdout;
	else {
		(void) mktemp(strcpy(filename, "/tmp/DSXXXXXX"));
		if ((f = fopen(filename,"w")) == NULL)
			perror("Can't open temp file");
	}
	
	if (gets(line)==NULL)
		exit(0);
	while (*line != '\0') {
		for (i=0;line[i] && line[i]!=':';i++)
			keyword[i]=line[i];
		keyword[i]='\0';
		MakeLowerCase(strcpy(key,keyword));
		if (list_compare(key,subjlist)) {
			for (i++;line[i]==' ';i++) ;
			(void) strcpy(subject,line+i);
		}
		if (CheckField(key))
			fprintf(f,"%s\n",line);
		if (zipgun && list_compare(key,zippy))
			fprintf(f,"%s: <CENSORED by the Net-Police>\n",keyword);
		if (gets(line)==NULL)
			goto bye;
	}
	fprintf(f,"\n");
	while (gets(line)!=NULL)
		fprintf(f,"%s\n",line);
	if (!debug)
		if (fclose(f) == EOF)
			perror("Can't close temp file.");
	PipeToMeeting(filename,*subject ? subject : DEFAULT_SUBJECT);
 bye:
	(void) unlink(filename); 
	exit(0);
	
}

void PipeToMeeting(filename,subject)
	char *filename, *subject;
{
	char command[100], line[100];
	FILE *f,*dspipe;

	(void) sprintf(command,"%s %s -t \"%s\"",DSPIPE,usr_mtg,subject);
	if (debug) {
		printf("<----------------- End of Text\n");
		printf("pipe to: %s\n",command);
		return;
	}
	if ((f = fopen(filename,"r")) == NULL)
		perror("Can't reopen temp file.");
	if ((dspipe = popen(command,"w")) == NULL)
		{
			fprintf(stderr,"Can't fork to %s",DSPIPE);
			exit(1);
		}
	(void) fgets(line,255,f);
	while (!feof(f)) {
		(void) fputs(line,dspipe);
		(void) fgets(line,255,f);
	}
	(void) pclose(dspipe);
	(void) fclose(f);
}

void MakeLowerCase(s)
	char *s;
{
	int i;
	for (i=0;s[i];i++)
		s[i]=isupper(s[i]) ? tolower(s[i]) : s[i];
}

int CheckField(key)
	char *key;
{
	int keepfield;

	keepfield=allfields;
	if (dodefs && list_compare(key,deflist))
		keepfield=1;
	if (list_compare(key,save))
		keepfield=1;
	if (list_compare(key,reject))
		keepfield=0;
	return(keepfield);
}

/* Parse command line arguments */
void PRS(argc,argv)
	int argc;
	char **argv;
{
	int c,rp,sp;
	
	progname=argv[0];
	sp=rp=0;
	optind=1;		/* Initialize for getopt */
	while ((c = getopt(argc,argv,"AZDda:r:")) != EOF)
		switch(c) {
		case 'Z':  
			zipgun=!zipgun;
			break;
		case 'd':
			dodefs=!dodefs;
			break;
		case 'D':
			debug=!debug;
			break;
		case 'A':
			allfields=!allfields;
			break;
		case 'a':
			MakeLowerCase(optarg);
			save[sp++]=optarg;
			break;
		case 'r':
			MakeLowerCase(optarg);
			reject[rp++]=optarg;
			break;
			}    
	if (optind>=argc) 
		goto lusage;
	usr_mtg=argv[optind];
	save[sp]=NULL;		/* Insert terminators */
	reject[rp]=NULL;
	return;
 lusage:
	printf("Usage: %s [-dADZ] [-a field] [-r field] meeting-path-name\n",
	       progname);
	exit(1);
}

char *re_comp();

int list_compare(s,list)
	char *s,**list;
{
	char *err;

	while (*list!=NULL) {
		err=re_comp(*list++);
		if (*err) {
			fprintf(stderr,"%s: %s - %s\n",progname,err,*(--list));
			exit(1);
			}
		if (re_exec(s))
			return(1);
	}
	return(0);
}

void perror(s)
	char *s;
{
	fprintf(stderr,"%s: %s\n",progname,s);
	exit(1);
}

